#include "common.h"
#include "system/sound.h"


// 0x20 toggles whether we use the alternate sample bank
#define SOUND_BANK_FLAG_ALT_SAMPLE_BANK      (1u << 5)   // 0x20

// the instrument index window that is eligible for bank remap
#define SOUND_BANK_REMAP_BASE_INDEX          0x20u       // first remappable instrument
#define SOUND_BANK_REMAP_COUNT               0x40u       // 64 instruments (0x20..0x5F)

// how far to shift SPU sample addresses when remapping
#define SOUND_BANK_SPU_ADDR_OFFSET           0x30000u

extern s32 D_80094FAC[];
extern s32 D_80094FFC;

//----------------------------------------------------------------------------------------------------------------------
u16 Sound_ApplySampleBankOffsetIfNeeded( u32 in_Flags, FSoundChannel* in_pChannel )
{
    if( in_Flags & SOUND_BANK_FLAG_ALT_SAMPLE_BANK &&
            (in_pChannel->InstrumentIndex - SOUND_BANK_REMAP_BASE_INDEX) < SOUND_BANK_REMAP_COUNT
    )
    {
        in_pChannel->VoiceParams.StartAddress += SOUND_BANK_SPU_ADDR_OFFSET;
        in_pChannel->VoiceParams.LoopAddress  += SOUND_BANK_SPU_ADDR_OFFSET;
        in_pChannel->InstrumentIndex          += SOUND_BANK_REMAP_BASE_INDEX; // mirror into alt-bank instrument table
    }
    return in_pChannel->InstrumentIndex;
}

//----------------------------------------------------------------------------------------------------------------------
INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", func_8004DDA4);

//----------------------------------------------------------------------------------------------------------------------
#ifndef NON_MATCHING
INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", Sound_ReconcileSavedMusicVoices);
#else
void Sound_ReconcileSavedMusicVoices()
{
    FSoundChannel* pChannel;
    u32 ActiveAlloc;
    u32 ActiveKeyed;
    u32 SavedAlloc;
    u32 SavedKeyed;
    u32 VoicesToKeyOff;
    u32 KeyOffFlags;
    u32 Bit;
    s32 VoiceIndex;
    s32 Count;

    if( !g_pSavedMousicConfig )
    {
        return;
    }

    ActiveAlloc = g_pActiveMusicConfig->AllocatedVoiceMask;   /* +0x08 */
    ActiveKeyed = g_pActiveMusicConfig->KeyedMask;            /* +0x0C */
    SavedAlloc  = g_pSavedMousicConfig->AllocatedVoiceMask;   /* +0x08 */
    SavedKeyed  = g_pSavedMousicConfig->KeyedMask;            /* +0x0C */

    VoicesToKeyOff =
        (~( SavedKeyed & ( (~(ActiveAlloc & ActiveKeyed)) | (SavedAlloc & SavedKeyed) ) ) )
        & ActiveKeyed
        & 0x00FFFFFF;

    KeyOffFlags = 0;
    VoiceIndex = 0;

    while( VoicesToKeyOff != 0 )
    {
        Bit = 1u << VoiceIndex;
        if( VoicesToKeyOff & Bit )
        {
            pChannel = g_pSecondaryMusicChannels;
            
            for( Count = 0; Count < 0x20; Count++ )
            {
                if( pChannel->VoiceParams.AssignedVoiceNumber == (u32)VoiceIndex )
                {
                    pChannel->VoiceParams.AssignedVoiceNumber = 0x18;
                    KeyOffFlags |= Bit;
                }
                pChannel++;
            }

            VoicesToKeyOff &= ~Bit;
        }

        VoiceIndex++;
    }

    g_Sound_VoiceSchedulerState.KeyOffFlags |= KeyOffFlags;
}
#endif

//----------------------------------------------------------------------------------------------------------------------
INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", func_8004DED8);

//----------------------------------------------------------------------------------------------------------------------
void Sound_ResetChannel( FSoundChannel* in_pChannel, u8* in_ProgramCounter )
{
    in_pChannel->VolumeBalance = 0x6E00;
    in_pChannel->Volume = 0x32000000;
    in_pChannel->ProgramCounter = in_ProgramCounter;
    in_pChannel->Transpose = 0;
    in_pChannel->FineTune = 0;
    in_pChannel->PortamentoSteps = 0;
    in_pChannel->PitchSlide = 0;
    in_pChannel->PitchBendSlideTranspose = 0;
    in_pChannel->PitchSlideStepsCurrent = 0;
    in_pChannel->LengthFixed = 0;
    in_pChannel->LengthStored = 0;
    in_pChannel->ChannelVolumeSlideLength = 0;
    in_pChannel->FinePitchDelta = 0;
    in_pChannel->RandomPitchDepth = 0;
    in_pChannel->LoopStackTop = 0;
    in_pChannel->UpdateFlags = 0;
    in_pChannel->AutoPanVolume = 0;
    in_pChannel->SfxMask = 0;
    in_pChannel->OpcodeStepCounter = -1;
    in_pChannel->VoiceParams.VolumeScale = 0;
    in_pChannel->AutoPanDepth = 0;
    in_pChannel->TremeloDepth = 0;
    in_pChannel->VibratoDepth = 0;
    in_pChannel->AutoPanDepthSlideLength = 0;
    in_pChannel->TremeloDepthSlideLength = 0;
    in_pChannel->VibratoDepthSlideLength = 0;
    in_pChannel->AutoPanRateSlideLength = 0;
    in_pChannel->TremeloRateSlideLength = 0;
    in_pChannel->VibratoRateSlideLength = 0;
    in_pChannel->FmTimer = 0;
    in_pChannel->NoiseTimer = 0;
    Sound_SetInstrumentToChannel(in_pChannel, 0U);
}

//----------------------------------------------------------------------------------------------------------------------
u32 ChannelMaskToVoiceMask( FSoundChannel* in_pChannel, u32 in_ChannelMask )
{
    u32 VoiceNumber, Mask;
    u32 i = 0;
    u32 out_VoiceMask = 0;

    while( i < SOUND_CHANNEL_COUNT )
    {
        Mask = 1 << i;
        if( in_ChannelMask & Mask )
        {
            VoiceNumber = in_pChannel->VoiceParams.AssignedVoiceNumber;
            if( VoiceNumber < VOICE_COUNT )
            {
                out_VoiceMask |= 1 << VoiceNumber;
            }
        }
        i++;
        in_pChannel++;
    };
    return out_VoiceMask;
}

//----------------------------------------------------------------------------------------------------------------------
#ifndef NON_MATCHING
INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", Sound_LoadAkaoSequence);
#else
void Sound_LoadAkaoSequence( FAkaoSequence* in_Sequence, s32 in_Mask )
{
    FSoundChannel* pChannel;
    FSoundKeymapEntry8* KeymapRegionStart;
    s16 ChannelLength;
    s32 PatchRegionOffset;
    s32 KeymapRegionOffset;
    s32 EnabledMask;
    s32 ChannelMask;
    u16* PatchRegionStart;
    u32 VoiceMask;
    u32 ChannelEnableMask;
    u32 ChannelIndex;
    u8* pData;
    u16 Offset;

    g_pActiveMusicConfig->SequenceBase = in_Sequence;
    ChannelEnableMask = in_Sequence->ChannelEnableMask;
    if( g_pSavedMousicConfig != NULL )
    {
        VoiceMask = ChannelMaskToVoiceMask(g_pSecondaryMusicChannels, g_pSavedMousicConfig->ActiveChannelMask);
    }
    else
    {
        VoiceMask = 0;
    }
    
    g_Sound_VoiceSchedulerState.KeyOffFlags |= ~VoiceMask & (~(D_80094FAC[0] | g_Sound_VoiceSchedulerState.ActiveChannelMask)) & 0xFFFFFF;
    g_pActiveMusicConfig->PendingKeyOffMask = 0;
    g_pActiveMusicConfig->PreventRekeyOnMusicResumeMask = 0;
    
    if( D_80094FFC & 1 )
    {
        g_pActiveMusicConfig->ActiveChannelMask = 0;
        g_pActiveMusicConfig->LastChannelModeFlags |= ChannelEnableMask & in_Mask;
    }
    else
    {
        g_pActiveMusicConfig->LastChannelModeFlags = 0;
        g_pActiveMusicConfig->ActiveChannelMask |= ChannelEnableMask & in_Mask;
    }
    
    g_pActiveMusicConfig->KeyedMask = in_Sequence->KeyedMask;
    g_pActiveMusicConfig->AllocatedVoiceMask = in_Sequence->AllocatedVoiceMask;
    g_pActiveMusicConfig->StatusFlags &= ~0x33;
    
    PatchRegionOffset = in_Sequence->PatchRegionOffset;
    PatchRegionStart = NULL;
    if( PatchRegionOffset != 0 )
    {
        PatchRegionStart = (u16*)((u8*)&in_Sequence->PatchRegionOffset + PatchRegionOffset);
    }
    g_pActiveMusicConfig->SequencePatchTable = PatchRegionStart;
    
    KeymapRegionOffset = in_Sequence->KeymapRegionOffset;
    KeymapRegionStart = NULL;
    if( KeymapRegionOffset != 0 )
    {
        KeymapRegionStart = (FSoundKeymapEntry8*)((u8*)&in_Sequence->KeymapRegionOffset + KeymapRegionOffset);
    }
    g_pActiveMusicConfig->KeymapTable = KeymapRegionStart;
    
    ChannelMask = 1;
    ChannelIndex = 0;
    pChannel = g_ActiveMusicChannels;
    pData = in_Sequence->Payload;
    g_pActiveMusicConfig->SomeIndexRelatedToSpuVoiceInfo = 0;
    
    D_80090A34 = 1;
    do
    {
        EnabledMask = ChannelEnableMask & ChannelMask;
        ChannelLength = 4;
        if( EnabledMask & in_Mask )
        {
            Offset = *pData;
            pChannel->ProgramCounter = &pData[*(u16*)pData];
            pData += 2;
            if( D_80094FFC & 0x100 )
            {
                ChannelLength = 0x1E4;
            }
            pChannel->Length2 = 2;
            pChannel->VolumeBalance = 0x7F00;
            pChannel->Volume = 0x3FFF0000;
            pChannel->C_Value = 0x4000;
            pChannel->Length1 = ChannelLength;
            pChannel->FineTune = 0;
            pChannel->Transpose = 0;
            pChannel->PortamentoSteps = 0;
            pChannel->PitchSlide = 0;
            pChannel->PitchBendSlideTranspose = 0;
            pChannel->PitchSlideStepsCurrent = 0;
            pChannel->LengthFixed = 0;
            pChannel->LengthStored = 0;
            pChannel->ChannelPan = 0x8000;
            pChannel->ChannelPanSlideLength = 0;
            pChannel->PortamentoSteps = 0;
            pChannel->C_StepsRemaining = 0;
            pChannel->ChannelVolumeSlideLength = 0;
            pChannel->FinePitchDelta = 0;
            pChannel->KeyOnVolumeSlideLength = 0;
            pChannel->RandomPitchDepth = 0;
            pChannel->UpdateFlags = ((g_pActiveMusicConfig->AllocatedVoiceMask & VoiceMask) == 0) << 6;
            pChannel->SfxMask = 0;
            pChannel->AutoPanVolume = 0;
            pChannel->LoopStackTop = 0;
            pChannel->AutoPanDepth = 0;
            pChannel->TremeloDepth = 0;
            pChannel->VibratoDepth = 0;
            pChannel->AutoPanDepthSlideLength = 0;
            pChannel->TremeloDepthSlideLength = 0;
            pChannel->VibratoDepthSlideLength = 0;
            pChannel->AutoPanRateSlideLength = 0;
            pChannel->TremeloRateSlideLength = 0;
            pChannel->VibratoRateSlideLength = 0;
            pChannel->FmTimer = 0;
            pChannel->NoiseTimer = 0;
            Sound_SetInstrumentToChannel(pChannel, 0);
        }
        else
        {
            if( EnabledMask != 0 )
            {
                if( !(ChannelMask & in_Mask) )
                {
                    pData += 2;
                }
            }
            pChannel->Length1 = 3;
            pChannel->Length2 = 1;
            pChannel->ProgramCounter = (u8* ) &g_Sound_ProgramCounter;
            pChannel->VoiceParams.VoiceParamFlags |= 0x4400;
            pChannel->VoiceParams.AdsrUpper = (pChannel->VoiceParams.AdsrUpper & 0xFFE0) | 5;
        }
        pChannel->VoiceParams.AssignedVoiceNumber = 0x18;
        ChannelEnableMask &= ~ChannelMask;
        pChannel++;
        ChannelIndex++;
        ChannelMask <<= 1;
    } while( ChannelIndex < SOUND_CHANNEL_COUNT );

    g_pActiveMusicConfig->Tempo = -0x10000;
    g_pActiveMusicConfig->TempoUpdate = 1;
    g_pActiveMusicConfig->TempoSlideLength = 0;
    g_pActiveMusicConfig->RevDepth = 0;
    g_pActiveMusicConfig->ReverbDepthSlideLength = 0;
    g_pActiveMusicConfig->ReverbDepthSlideStep = 0;
    g_Sound_GlobalFlags.UpdateFlags = 0;
    g_pActiveMusicConfig->TimerLowerCurrent = 0;
    g_pActiveMusicConfig->TimerLower = 0;
    g_pActiveMusicConfig->TimerUpperCurrent = 0;
    g_pActiveMusicConfig->TimerTopCurrent = 0;
    g_pActiveMusicConfig->NoiseChannelFlags = 0;
    g_pActiveMusicConfig->ReverbChannelFlags = 0;
    g_pActiveMusicConfig->FmChannelFlags = 0;
    g_pActiveMusicConfig->JumpThresholdValue = 0;
    g_pActiveMusicConfig->ActiveNoteMask = 0;
    g_pActiveMusicConfig->PendingKeyOnMask = 0;
    g_Sound_GlobalFlags.UpdateFlags |= 0x100;
}
#endif

//----------------------------------------------------------------------------------------------------------------------
void Sound_KillMusicConfig( FSoundChannelConfig* in_Config, FSoundChannel* in_pChannel, u32 arg2 )
{
    FSoundChannel* pChannel;
    FSoundChannelConfig** ppThisChannelConfig;
    u32 Count;

    pChannel = in_pChannel;
    if( (in_Config->ActiveChannelMask != 0) && ((arg2 == 0) || (arg2 == in_Config->MusicId)))
    {
        in_Config->PendingKeyOffMask = -1;
        for( Count = SOUND_CHANNEL_COUNT; Count != 0; Count-- )
        {
            pChannel->Length1 = 3;
            pChannel->Length2 = 1;
            pChannel->ProgramCounter = (u8*)&g_Sound_ProgramCounter;
            pChannel++;
        };

        ppThisChannelConfig = g_Sound_VoiceChannelConfigs;
        in_Config->MusicId = 0;
        in_Config->ActiveNoteMask = 0;
        in_Config->PendingKeyOnMask = 0;

        for( Count = 0; Count < VOICE_COUNT; Count++ )
        {
            if( *ppThisChannelConfig == in_Config )
            {
                *ppThisChannelConfig = NULL;
                SetVoiceAdsrReleaseRateAndMode(Count, 5, 3U);
            }
            ppThisChannelConfig++;
        };
    }
}

//----------------------------------------------------------------------------------------------------------------------
INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", func_8004E478);

INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", func_8004E7D8);

//----------------------------------------------------------------------------------------------------------------------
void FreeVoiceChannels( FSoundChannel* in_Channel, u32 in_Voice )
{
    u32 VoiceIndex;

    if( in_Voice < VOICE_COUNT )
    {
        VoiceIndex = 0;
        while( VoiceIndex < SOUND_CHANNEL_COUNT )
        {
            if( in_Channel->VoiceParams.AssignedVoiceNumber == in_Voice )
            {
                in_Channel->VoiceParams.AssignedVoiceNumber = VOICE_COUNT;
                g_pActiveMusicConfig->ActiveNoteMask &= ~(1 << VoiceIndex);
            }
            in_Channel++;
            VoiceIndex++;
        };
    }
}

INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", func_8004E9D0);

INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", func_8004EBC8);

//----------------------------------------------------------------------------------------------------------------------
// Unknown exactly how this functions but it is setting bits 0 and 1 to each channel in the incoming struct's flags
void Sound_MarkActiveChannelsVolumeDirty( FSoundChannelConfig* in_pChannelConfig, FSoundChannel* in_pChannel )
{
    u32 ActiveChannelMask;
    u32 Flags;
    u32 Mask;

    ActiveChannelMask = in_pChannelConfig->ActiveChannelMask;
    if( ActiveChannelMask == 0 )
    {
        return;
    }

    Flags = ActiveChannelMask;
    Mask = 1;

    while( Flags != 0 )
    {
        if( Flags & Mask )
        {
            in_pChannel->VoiceParams.VoiceParamFlags |= VOICE_PARAM_VOLUME;
            Flags ^= Mask;
        }
        in_pChannel++;
        Mask <<= 1;
    }
}

//----------------------------------------------------------------------------------------------------------------------
void Sound_MarkScheduledSfxChannelsVolumeDirty()
{
    u32 Mask;
    u32 ActiveChannelMask;
    FSoundChannel* pChannel;

    if( g_Sound_VoiceSchedulerState.ActiveChannelMask == 0 )
    {
        return;
    }

    ActiveChannelMask = g_Sound_VoiceSchedulerState.ActiveChannelMask;
    pChannel = SfxSoundChannels;
    Mask = (1 << 12); // SFX Channels start at channel 12
    while( ActiveChannelMask != 0 )
    {
        if( ActiveChannelMask & Mask )
        {
            ActiveChannelMask ^= Mask;
            pChannel->VoiceParams.VoiceParamFlags |= VOICE_PARAM_VOLUME;
        }
        pChannel++;
        Mask <<= 1;
    };
}

//----------------------------------------------------------------------------------------------------------------------
#ifndef NON_MATCHING
INCLUDE_ASM("asm/slps_023.64/nonmatchings/system/sound2", Sound_SetMusicSequence);
#else
void Sound_SetMusicSequence( FAkaoSequence* in_Sequence, s32 in_SwapWithSavedState )
{
    FAkaoSequence* PrevSequence;
    FSoundChannel* pChannel;
    u32 Delta;
    u32 Mask;
    u32 Flags;
    u32 ActiveChannelMask;
    u32 PrevActiveChannelMask;
    u32 VoiceMask;
    u32 VoicesToKeyOff;
    u32 UnusedVoices;

    if (in_SwapWithSavedState == 0)
    {
        memcpy32(&g_PushedMusicConfig, g_pActiveMusicConfig, 0x80U);
        memcpy32(g_PushedMusicChannels, g_ActiveMusicChannels, 0x2480U);
    }
    else
    {
        memswap32(&g_PushedMusicConfig, g_pActiveMusicConfig, 0x80U);
        memswap32(g_PushedMusicChannels, g_ActiveMusicChannels, 0x2480U);
    }
    pChannel = g_ActiveMusicChannels;
    Flags = 0x20;
    Mask = 1;
    PrevSequence = g_pActiveMusicConfig->SequenceBase;
    g_pActiveMusicConfig->SequenceBase = in_Sequence;
    g_pActiveMusicConfig->PendingKeyOnMask = 0;
    g_pActiveMusicConfig->StatusFlags &= ~0x30;
    Delta = (u32)in_Sequence - (u32)PrevSequence;
    g_Sound_GlobalFlags.UpdateFlags |= 0x90;
    ActiveChannelMask = g_pActiveMusicConfig->ActiveChannelMask;
    (u32)g_pActiveMusicConfig->SequencePatchTable += Delta;
    (u32)g_pActiveMusicConfig->KeymapTable += Delta;
    g_pActiveMusicConfig->PendingKeyOnMask = g_pActiveMusicConfig->ActiveNoteMask;
   
    while (Flags != 0) {
        if( ActiveChannelMask & Mask )
        {
            pChannel->ProgramCounter += Delta;
            pChannel->Keymap += Delta;
            pChannel->LoopStartPc[0] += Delta;
            pChannel->LoopStartPc[1] += Delta;
            pChannel->LoopStartPc[2] += Delta;
            pChannel->LoopStartPc[3] += Delta;
            pChannel->Length1 += 2;
            pChannel->Length2 += 2;
            pChannel->VoiceParams.VoiceParamFlags |= 0x1FF93;
            Sound_ApplySampleBankOffsetIfNeeded((u32) g_pActiveMusicConfig->StatusFlags, pChannel);
        }
        else
        {
            pChannel->Length1 = 4U;
            pChannel->Length2 = 2U;
            pChannel->ProgramCounter = (u8*)&g_Sound_ProgramCounter;
        }
        pChannel->VoiceParams.AssignedVoiceNumber = 0x18;
        Flags--;
        pChannel++;
        Mask <<= 1;
    }
    
    if( g_pSavedMousicConfig )
    {
        VoiceMask = ChannelMaskToVoiceMask( g_pSecondaryMusicChannels, g_pSavedMousicConfig->ActiveChannelMask & g_pSavedMousicConfig->KeyedMask );
    }
    else
    {
        VoiceMask = 0;
    }
    
    g_PushedMusicConfig.MusicId = 0;
    g_pActiveMusicConfig->PendingKeyOffMask = 0;

    // a0 = ~VoiceMask
    // a1 = g_Sound_VoiceSchedulerState
    // v0 = g_Sound_VoiceSchedulerState.ActiveChannelMask
    // v1 = D_80094FAC


    // nor     v1,v1,v0
    UnusedVoices = g_Sound_VoiceSchedulerState.ActiveChannelMask;
    UnusedVoices = ~(D_80094FAC[0] | g_Sound_VoiceSchedulerState.ActiveChannelMask);

    UnusedVoices &= 0xFFFFFF;

    VoicesToKeyOff = ~VoiceMask;
    VoicesToKeyOff &= UnusedVoices;
    

    // lw      v0,0xc(a1)
    // or      v0,v0,a0
    g_Sound_VoiceSchedulerState.KeyOffFlags |= VoicesToKeyOff;
    g_Sound_GlobalFlags.UpdateFlags |= 0x100;
    
    if( D_80094FFC & 1 )
    {
        PrevActiveChannelMask = g_pActiveMusicConfig->ActiveChannelMask;
        g_pActiveMusicConfig->ActiveChannelMask = 0;
        g_pActiveMusicConfig->LastChannelModeFlags = PrevActiveChannelMask;
    }
}
#endif
